/* JavaScript Numbers */
    - No different number types
    - JS uses the + operator for both addition and concatenation.
        - Numbers are added. Stings are concatenated.
        - Adding a number and a string results in a string concatenation.



/* Numeric Strings */ 
    - JS will try to convert strings to numbers in all numeric operations:
        var x = "100";
        var y = "10";
        var z = x / y;      // z will be 10
    - Division, multiplication and subtraction will all work in the above numberic calculation. However, addition (+) will result in a string.



/* NaN (Not a Number) */
    - NaN (Not a Number): a reserved word indicating that a number is not a legal number. Trying to do an arithmetic with a non-numeric string will result in NaN.
        var x = 100 / "Apple";      // x will be NaN
    - However, if the string contains a numberic value, the result will be a number.
        var x = 100 / "10";         // x will be 10
    _ You can use the global JS function `isNaN()` to find out if a value is a number:
        var x = 100 / "Apple";
        isNaN(x);                   // retunrs true because x is Not a Number
    - If you use NaN in a mathematical operation, the result will also be NaN:
            var x = NaN;
            var y = 5;
            var z = x + y;              // z will be NaN
        - Or a concatenation:
            var x = NaN;
            var y = "5";
            var z = x + y;              // z will be NaN5
    - NaN is a number 
        typeof NaN;                     // returns "number"



/* Infinity */
    - `Infinity` (or `-Infinity`) is the value JS will return if you calculate a number outside the largest possible number.
        var myNumber = 2;
        while (myNumber != Infinity) {      // Execute until Infinity
            myNumber = myNumber * myNumber;
        }
    - Division by 0 (zero) also generates Infinity
        var x = 2 /0;           // x will be Infinity
        var y = -2 / 0;         // x will be -Infinity
    - `Infinity` is a number: `typeof Infinity` returns `number`.
        typeof Infinity;        // returns "number"



/* Hexadecimal */
    - JS interprets numeric constants as hexadecimal if they are preceded by 0x.
        var x = 0xFF;           // x will be 255
    - NEVER WRITE A NUMBER WITH A LEADING ZERO (LIKE 07). SOME JS VERSIONS INTERPRET NUMBERS AS OCTAL IF THEY ARE WRITTEN WITH A LEADING ZERO.
    - By default, JS desplays numbers as 'base 10' decimals, but you can use the `toString()` method to output numbers from 'base 2' to 'base 36'. Hexadecimal is 'base 16', decimal is 'base 10', octal is 'base 8' and binary is 'base 2'.
        var myNumber = 32;
        myNumber.toString(10);  // returns 32
        myNumber.toString(32);  // returns 10
        myNumber.toString(16);  // returns 20
        myNumber.toString(8);   // returns 40
        myNumber.toString(2);   // returns 100000



/* Numbers Can be Objects */
    - Normally JS numbers are primitive values created from literals
        var x = 123;                    // typeof x returns number
    - Numbers can also be defined as objects with the keyword `new`:
        var y = new Number(123);        // typeof y returns objects
    - DO NOT CREATE NUMBER OBJECTS. IT SLOWS DOWN EXECUTION SPEED.
        - The `new` keyword complicates the code. This can reproduce some unexpected results.
    - When using the `==` operator, equal numbers are equal:
        var x = 500;
        var y = new Number(500);
            // (x == y) is true because x and y have equal values
    - When using the === operator, equal numbers are not equal, beause the === operator EXPECTS EQUALITY IN BOTH TYPE AND VALUE.
        var x = 500;
        var y = new Number(500);
            // (x === y) is false because x and y have different types
    - Objects cannot be compared
        var x = new Number(500);
        var y = new Number(500);
            // (x == y) is false because objects cannot be compared
        - COMPARING TWO JS OBJECTS WILL ALWAYS RETURN `false`



/* JS Arithmetic Operators */
    - Arithmetic operators perform arithmetic on numbers (literals or variables).
        Operators           Description
            +                   addition
            -                   subtraction
            *                   multiplication
            **                  exponentation
            /                   Division
            %                   modulus (remainder)
            ++                  increment
            --                  decrement



/* Arithmetic operations */
    - A typical arithmetic operation operates on two numbers
        - The two numbers can be literals:
            var x = 100 + 50;
        - Or variables:
            var x = a + b;
        - Or expressions:
            var x = (100 + 50) * a;
    


/* Operators and Operands */
    - The numbers (in an arithmetic operation) are call operands.
    - The operation (to be performed betwee the two operands) is defined by an operator.
    - Adding
        The addition operator (+) add numbers:
            var x = 5;
            var y = 2;
            var z = x + y;
    - Subtracting
        The subtration operator (-) subtracts numbers:
            var x = 5;
            var y = 2;
            var z = x - y;
    - Multiplying
        The multiplication operator (*) multiplies numbers:
            var x = 5;
            var y = 2;
            var z = x * y;
    - Dividing
        The division operator (/) divides numbers:
            var x = 5;
            var y = 2;
            var z = x / y;
    - Remainder
        The modulus operator (%) returns the division remainder:
            var x = 5;
            var y = 2;
            var z = x % y;
        In arithmetic, the division of two integers produces a quotient and a remainder.
        In mathematics, the result of the modulo operation is the remainder of an arithmetic division.
    - Incrementing
        The increment operator (++) increments numbers:
            var x = 5;
            x++;
            var z = x;
    - Decrementing
        The decrement operator (--) decrements numbers:
            var x = 5;
            x--;
            var z = x;
    - Exponentiation
        The exponentiation operator (**) raises the first operand to the power of the second operand:
            var x = 5;
            var z = x ** 2;     // result is 25
        x ** y produces the same result as `Math.pow(x,y)`:
            var x = 5;
            var z = Math.pow(x,2);     // result is 25

    - Terms: "unary", "binary"
        An operator is 'unary' if it has a single operand (x = 3). For example, the unary negation `-` reverses the sign of a number:
            let x = 1;
            x = -x;
            alert(x);       // -1, unary negation was applied
        An operator is 'binary' if it has two operands (x=1, y=3). The same `-` exists in binary form as well:
            let x = 1, y = 3;
            alert( y-x );   // 2, binary minus subtracts values
        - In the examples above, we have two different operators that share the same symbol: the negation operator, a unary operator that reverses the sign, and the subtraction operator, a binary operator that subtracts one number from another.

    - Numberic conversion, unary +
        The plus (+) exists in two forms: the binary form and the unary form.
            The unary plus or, aka the + operator, applied to a single value doesn't do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.
                // No effect on numbers
                    let x = 1;
                    alert( +x );        // 1

                    let y = -2;
                    alert( +y );        // -2

                // Converts non-numbers
                    alert( +true );     // 1
                    alert( +"" );       // 0
                        // This does the same thing as `Number(...)`, but is shorter.
            
                // Example conversion using input values from a <form>
                    let apples = "2";
                    let oranges = "3";

                    // both values converted to numbers before the binary plus
                    alert( +apples + +oranges );   // 5

                    // the longer variant
                    alert( Number(apples) + Number(oranges) );  //5
            Unary pluses are applied first, they convert strings to numbers, and then the binary plus sums them up.
        
    - Chaining assignments
        Chained assignments evaluate from RIGHT to LEFT. 
            let a, b, c;

            a = b = c = 2 + 2;

            alert( a ); // 4
            alert( b ); // 4
            alert( c ); // 4
                // First, the rightmost expression (2 + 2) is evaluated and then assigned to the variables on the left: c, b and a (in that order). At the end, all the variables share a single value.
                // For the purposes of readability it's better to split such code into a few lines.
    
    - Modify-in-place
        Applying an operator to a variable and storing the new result in the same variable.
            let n = 2;
            n = n + 5;
            n = n * 2;      // n = 14
        Notation can be shortend using the operators += and *=
            let n = 2;
            n += 5;
            n *= 2;         // n = 14
        Such operators have the same precedence as the normal assignment, so they run after most other calculations.
            let n = 2;
            n *= 3 + 5;
            alert( n );     // 16 (right part evaluated first, same as n *= 8) 
        
    - Increment/decrement
        CAN ONLY BE APPLIED TO VARIABLES!
        The operators ++ and -- can be placed either before or after a variable.
            When the operator goes after the variable, it is in "postfix form": a++
            When the operator goes in front of the variable, it is in "prefix form": ++a
                The prefix form returns the new value while the postfix form returns the old value (prior to increment/decrement).
                    // Prefix example
                        let counter = 1;
                        let a = ++counter:      // (*)
                        alert( a ):             // 2
                        // In the line (*), the prefix form `++counter` increments `counter` and returns the new value, 2. So, the `alert` shows `2`.
                    // Postfix example
                        let counter = 1;
                        let a = counter++;      // (*) changed ++counter to counter++
                        alert( a );             // 1
                        // In the line (*); the postfix form `counter++` also increments `counter` but returns the old value (prior to increment). So the `alert` shows 1.
        If the result of increment/decrement is not used, there is no difference in which form to use.
            To increase the value and immediately use the result of the opeartor, use the PREFIX form.
            To increase the value but use the previous value, use the POSTFIX form.
        The operators ++/-- can be used inside expressions as well. Thier precedence is higher than most other arithmetical operations.

    - Bitwise operators
        Bitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.
        These operators are not JS-specific. They are supported in most programming languages.
            AND ( & )
            OR ( | )
            XOR ( ^ )
            NOT ( ~ )
            LEFT SHIFT ( << )
            RIGHT SHIFT ( >> )
            ZERO-FILL RIGHT SHIFT ( >>> )
        These operators are used very rarely, when we need to fiddle with numbers on the very lowest (bitwise) level. 
            Web development has little use for bitwise operators.
            In some special areas, such as cryptography, they are useful.

    - Comma 
        One of the rarest and most unusual operators. Sometimes, used to write shorter code.
            Allows us to evaluate several expressions, dividing them with a comma (,). 
            Each of them is evaluated but only the result of the last one is returned.
                let a = (1+2, 3+4);
                alert ( a );        // 7 (the result of 3+4)
        Comma operators have very low precedence, lower than =, so parentheses are important in the above example.
            Without them: `a = 1+2, 3+4;` evaluates + first, summing the numbers into `a = 3, 7`, then the assignment operator = assigns `a = 3`, and the rest is ignored. 
                Equivalent to `(a = 1 + 2), 3 + 4;`
        Commas are commonly used in more complex constructs to put seeral actions in one line.
            for (a = 1, b = 3, c = a * b; a < 10; a++) {
                ...
            }
            // three operations in one line
        Such tricks are used in many JS frameworks. That's why we're mentioning them, but usually they don't improve code readability so we should think well before using them.



/* Operaotr Precedence */
    - Operator Precedence
        Operator precedence describes the order in which operations are performed in an arithmetic expression.
        Multiplication (*) and division (/) have higher precedence than addition (+) and subtraction (-).
        The precedence can be changed by using parentheses.
        When many operations have the same precedence (like addition and subtraction), there are computed fom left to right.



/* JavaScript Operator Precedence Values */
    Value           Operator          Description                                        Example
        20              ( )             Expression grouping                                 (3+4)

        19              .               Member                                              person.name
        19              []              Member                                              person["name"]
        19              ()              Function call                                       myFunction()
        19              new             Create                                              new Date()

        17              ++              Postfix Increment                                   i++
        17              --              Postfix Decrement                                   i--

        16              ++              Prefix Increment                                    ++i
        16              --              Prefix Decrement                                    --i
        16              !               Logical not                                         !(x==y)
        16              typeof          Type                                                typeof x

        15              **              Exponentiation (ES2016 or higher)                   10 ** 2

        14              *               Multiplication                                      10 * 5
        14              /               Division                                            10 / 5
        14              %               Division Remainder                                  10 % 5

        13              +               Addition                                            10 + 5
        13              -               Subtraction                                         10 - 5

        12              <<              Shift Left                                          x << 2
        12              >>              Shift Right                                         x >> 2
        12              >>>             Shift Right (unsigned)                              x >>> 2

        11              <               Less than                                           x < y
        11              <=              Less than or equal                                  x <= y
        11              >               Greater than                                        x > y
        11              >=              Greater than or equal                               x >= y
        11              in              Property in Object  (ES2016 or higher)              "PI" in Math 
        11              instanceof      Instance of Object  (ES2016 or higher)              instanceof Array

        10              ==              Equal                                               x == y
        10              ===             Strict equal                                        x === y 
        10              !=              Unequal                                             x != y
        10              !==             Strict unequal                                      x !== y

        9               &               Bitwise AND                                         x & y
        8               ^               Bitwise XOR                                         x ^ y
        7               |               Bitwise OR                                          x | y
        6               &&              Logical AND                                         x && y 
        5               ||              Logical OR                                          x || y 
        4               ?:              Condition                                           ? "Yes : "No"

        3               +=              Assignment (modify-in-place)                        x += y
        3               /=              Assignment (modify-in-place)                        x /= y 
        3               -=              Assignment (modify-in-place)                        x -= y
        3               *=              Assignment (modify-in-place)                        x *= y 
        3               %=              Assignment (modify-in-place)                        x %= y 
        3               <<=             Assignment                                          x <<= y
        3               >>=             Assignment                                          x >>= y
        3               >>>=            Assignment                                          x >>>= y 
        3               &=              Assignment                                          x &= y
        3               ^=              Assignment                                          x ^= y
        3               |=              Assignment                                          x |= y 

        2               yield           Pause Function (ES2016 or higher)                   yield x 

        1               ,               Comma                                               5, 6

    - EXPRESSION IN PARENTHESES ARE FULLY COMPUTED BEFORE THE VALUE IS USED IN THE REST OF THE EXPRESSION.
    


/* Variables */
    - A "named storage" for data. Can be used to store goodies, visitors, and other data.
    - `let` keyword  
        Used to create a variable in JS
            let message;
        Now, we can put some data into it by using the assignment operator =:
            let message;
            message = 'Hello";      // store the string
        The string is now saved into the memory area associated with the variable and can be accessed using the variable name:
            let message:
            message = 'Hello!';
            alert( message );       // shows the variable concatenated
        The variable declaration and assignment can be combined into a single line:
            let message = 'Hello!';
            alert ( message );
        Multiple variables can be declared in one line (separated by a comma):
            let user = 'John', age = 25, message = 'Hello';
                NOT RECOMMENDED - for the sake of better readability, use a single line per variable 
                    let user = 'John',
                        age = 25,
                        message = 'Hello';
        `let` provides block-scoping that is absent in the fucntion-scoped `var`
            Example     var callbacks = [];
                        (function() {
                            for (let i = 0; i < 5; i++) {
                                callbacks.push( function() { return i; } );
                            }
                        })();
                        console.log(callbacks.map( function(cb) { reutnr cb(); } ));
            `let` stats in the block scope of the loop, causing a separate instance of i for each iteration.
            `var` would be hoisted(?) to the top of the function's scope 

    - `var` keyword
        In older scripts, you may also find the keyword `var`, used to declare variables
            var message = 'Hello';
        `var` is still useful in situations where you want to maintain function scope instead of block scope 
        
    - Changing variable values 
        Variable values can be changed as many times as we want:
                let message;
                message = 'Hello!';
                messgae = 'World!';
                alert( message );       // prints 'World!'
            When the value is changed, the old data is removed from the variable.

    - Copying data between variables
        Data can be copied from one variable to another   
            let hello = 'Hello world!';
            let message;
            message = hello;            // copy 'Hello world' from hello into message
            // now two variables hod the same data
            alert( hello );             // Hello world!
            alert( message );           // Hello world!

    - Declaring variables twice
        DECLARING TWICE TRIGGERS AND ERROR
            A variable should be declared only once
            A repeated declaration of the same variable is an error 
                let message = "this";
                let message = "that";   // SyntaxError: 'message' has already been declared
            Once a variable is declared, it should be referred to WITHOUT the keyword `let`

    - Variable naming
        There are two limitations on variable names in JS:
            1) The name must contain only letters, digits, or the symbols $ and _
            2) The first character must NOT be a digit
                let userName;
                let test123;
        When a name contains multiple words, camelCase is commonly used. 
            That is, words go one after another, each word except the first starting with a capital letter. 
            Ex: lutherCalvinRiggs
        The dollar sign ($) and the underscore (_) can also be used in names. They are regular symbols, just like letters, without any special meaning.
            let $ = 1;
            let _ = 2;
            alert( $ + _ );     // 3
        Examples of incorrect variable names:
            let 1a;             // cannot start with a digit
            let my-name;        // hyphens (-) aren't allowed in the name
        Case matters: variables named `apple` and `ApplE` are two different variables
        Non-Latin letters are allowed, but not recommended   
            It is possible to use any language, including cyrillic letters or even hieroglyphs, however, there is an international convention to use English in variable names.
            If your code has a long life, people from other countries may need to read it in the future.
        Reserved names  
            This is a list of reserved words which CANNOT be used as variable names because they are used by the language itself:
                let
                class
                return
                function 
        
    - `use strict`
        Normally, we need to define a variable before using it. But in the old times, it was technically possible to create a variable by a mere assignment of the value without using `let`. This still works now if we don't put `use strict` in our scripts to maintain compatibility with old scripts.
            // note: no "use strict" in this example
            num = 5;            // the variable "num" is created if it didn't exist
            alert( num );       // 5
            
            "use strict";
            num = 5;            // error: num is not defined 
    
    - Constants
        To declare a constant (unchanging) variable, use `const` instead of `let`:
            const myBirthday = '18.04.1982';
        Variables decared using `const` CANNOT by reassigned. An attempt to do so would cause an error:
            const myBirthday = '18.04.1982';
            myBirthday = '01.01.2001':          // error, can't reassign the constant!
                `const` will throw an error is an attempt is made to change its value after it has been declared, a useful feature to prevent accidental mutation.
        When a programmer is use that a variable will never change, they can declare it with `const` to guarantee and clearly communicate that fact to everyone
    - Uppercase constants 
        There is a widespread practice to use constants as aliases for difficult-to-remember values that are known prior to execution. 
        Such constants are named using capital letters and uncerscores
            Example of constants for collors in so-called "web" (hexadecimal) format:
                const COLOR_RED = "#F00"
                const COLOR_GREEN = "#0F0"
                const COLOR_BLUE = "#00F"
                const COLOR_ORANGE = "#FF7F00";
                // ...when we need to pick a color 
                let color = COLOR_ORANGE;
                alert( color );                     // #FF7F00
            Benefits:
                COLOR_ORANGE is much easier to remember than #FF7F00 
                It is much easier to mistype #FF7F00 than COLOR_ORANGE
                When reading the code, COLOR_ORANGE is much more meaningful than #FF7F00
            USE CAPITALS WHEN THE CONSTANTS ARE KNOWN PRIOR TO EXECUTION AND THERE ARE CONSTANTS THAT ARE CALCULATED IN RUN-TIME, DURING THE EXECUTION, BUT DO NOT CHANGE AFTER THEIR INITIAL ASSIGNMENT.
                In other words, capital-named constants are only used as aliases for "hard-coded" values 
    
    - Name things right
        A variable name should have a clean, obvious meaning, describing the data that it stores
            One of the things that separates the beginners from the experienced developers
            In a real project, most fo the time is spent modifying and extending an existing code base rather than writing something completely separate from scratch. When we return to some code after doing something else for a while, it's much easier to find information that is well-labeled, or uses good variable names.
            Some variable naming rules are:
                Use human-readable names like `userName` or `shoppingCart`
                Stay way from abbreviations or short names like `a, b, c`, unless you really know what you're doing
                Make names maximally descriptive and concise. Names like `data` and `value` are bad because they are too broad. Only use broad names if the context of the code makes it exceptionally obvious which data or value the variable is referencing.
                Agree on terms within your team and in your own mind. If a site visitor is called a "user" then we should name related variables `currentUser` or `newUser` instead of `currentVisitor` or `newManInTown`

    - Reuse or create
        Reusing variables is like having boxes into which people throw different things without changing their stickers. What's in the box now? Who knows? 
        This may save a little bit on variable declaration, but will lose ten times more on debugging
        EXTRA VARIABLES ARE GOOD 
            Modern JS minifiers and browsers optimize code well enough, so it won't create performance issues. 
            Using different variables for different values can even help the engine optimize your code.
    
    - Variables should be named in a way that allows us to easily understand what's inside them.



/* Data Types */
    - A value in JS is always of a certain type. For example, a string or a number.
    - There are eight basic data types in JS 
    - We can put any type in a variable. For example, a variable can at one moment be a string and then store a number.
        // no error
        let message = "hello";
        message = 123456;
    - Programming languages that allow such things, such as JS, are called "dynamically typed", meaning that there exists data types, but variables are not bound to any of them.

    - Number
            let n = 123;
            n = 12.345;
        The number type represents both integer and floating point numbers.
        Beyond regular numbers, there are so-called "special numberic values" which also belong to this data type: 
            `Infinity` 
                Represents the mathematical Infinity and is a special value that's greater than any number
                We can get it as a result of division by zero 
                    alert( 1 / 0 );        // Infinity
                Or just reference it directly
                    alert( Infinity );      // Infinity
            `-Infinity` 
            `NaN`
                Represents a computational error. It is a result of an incorrect or an undefined mathematical operation, for instance:
                    alert( "not a number" / 2 );        // NaN, such division is erroneous
                NaN is sticky. Any further operation on NaN reutnrs NaN:
                    alert( "not a number" / 2 + 5 );    // NaN 
        Special numberic values formally belong to the "number" type. Of course they are not numbers in the common sense of this word.
            Doing maths is "safe" in JS. We can do anything: divide by zero, treat non-nmeric strings as numbers, etc.
            The script will never stop with a fatal error ("die"). At worst, we'll get NaN as the result.

    -BigInt
        In JS, the "number" type cannot represent integer values larger than (2^53-1), (or 9007199254740991), or less than -(-2^53-1) for negatives. It's a technical limitation caused by their internal representation.
        For most purposes that's quite enough, but sometimes we need really big numbers, eg for cryptography or microsecond-precision timestamps.
        `BigInt` type was recently added to the language to represent integers of arbitrary length.
        A `BigInt` value is created by appending `n` to the end of an integer:
            // the "n" at the end means it's a BigInt
            const bigInt = 1234567890123456789012345678901234567890n;
        Right now `BigInt` is supported in Firefox/Chrome/Edge, but not in Safari/IE. (7.1.2020)

    - String
        A STRING IN JS MUST BE SURROUNDED BY QUOTES
        In JS, there are 3 types of quotes:
            Double and single quotes are "simple" quotes. There's practically no difference between them in JS.
                Double quotes: "Hello"
                    let str = "Hello";
                Single quotes: 'Hello'
                    let str2 = 'Single quotes are ok too';
            Backticks are "extended functionality" quotes. They allow us to embed variables and expressions into a string by wrapping them in ${_}. The expression inside ${...} is evaluated and the result becomes a part of the string. Anything can be put into the ${...}
                Backticks: `Hello`
                    let phrase = `can embed another ${str}`;

                    let name = "John";
                    // embed a variable
                    alert( `Hello, ${name}!` );         // Hello, John!
                    // embed an expression
                    alert( `the result is ${1+2}` );    // the result is 3
        There is no 'character' type.
            In som languages, there is a special "character" type for a single character. For example, in the C language and in Java it is called "char".
            In JS, there is no such type. There's only one type: `string`. A string may consist of only one character or many of them.
    
    - Boolean (logical type)
        The boolean type has only two values: `true` and `false`
        This type is commonly used to store yes/no values: `true` means "yes, correct", and `false` means "no, incorrect".
            let nameFieldChecked = true;        // yes, name field is checked 
            let ageFieldChecked = false;        // no, age field is not checked 
        Boolean values also come as a result of comparisons:
            let isGreater = 4 > 1;
            alert( isGreater );         // true (the comparison result is "yes")
        
    - The "null" value 
        The special `null` value does not belong to any of the types described above.
        It forms a separate type of its own which contains only the `null` value:
            let age = null;
            // This code states that `age` is unknown 
        In JS, `null` is not a "reference to a non-existing object" or a "null pointer" like in some other languages. It's just a special value which represents "nothing", "empty" or "value unknown".
    
    - The "undefined" value 
        The special value `undefined` also stands apart. It makes a type of its own, just like `null`.
        The meaning of `undefined` is "value is not assigned"
        If a variable is declared, but not assigned, then its value is `undefined`:
            let age;
            alert( age );       // shows "undefined"
        Technically, it is possible to explicitly assign `undefined` to a variable:
                let age = 100;
                // change the value to undefined 
                age = undefined;
                alert( age );       // "undefined"
            ...But this is not recommended. 
        Normally, one uses `null` to assign an "empty" or "unknown" value to a variable, while `undefined` is reserved as a default initial value for unassigned things. 

    - Objects and Symbols
        The `object` type is special.
            All other types are called "primitive" because their values can contain only a single thing (be it a string or a number or whatever). In contrast, objects are used to store collections of data and more complex entities.
        The `symbol` type is used to create unique identifiers for objects.

    - The typeof operator 
        The `typeof` operator returns the type of the argument. It's useful when we want to process values of different types differently or just want to do a quick check. 
        It supports to forms of syntax (meaning it works with parentheses or without them):
            1) As an operator: `typeof x`
            2) as a function: `typeof(x)`
        The call to `typeof x` returns a string with a type name:
            typeof undefines            // "undefined"
            typeof 0                    // "number"
            typeof 10n                  // "bigint"
            typeof true                 // "boolean"
            typeof "foo"                // "string"
            typeof Symbol("id")         // "symbol"
            typeof Math                 // "object"
                // `Math` is a built-in object that provides mathematical operations.
            typeof null                 // "object"
                // This is an officially recognized error in `typeof` behavior, coming from the early days of JS and kept for compatibility. Definitely, `null` is not an object. It is a special value with a separate type of its own.
            typeof alert                // "function"
            


/* Strings */
    - A string is simply a piece of text. 
    - String methods help you to work with strings.

    - String Methods and Properties
        Primitive values, like "John Doe", cannot have properties or methods (because they are not objects).
        Yet, JS treats primitive values as objects when executing methods and properties.

    - String length
        The `length` property returns the length of a string 
            let txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            let sln = txt.length;           // 26
    
    - Finding a string in a string
        The `indexOf()` method returns the index of (the position of) the `first` occurrence of a specified text in a string:
            let str = "Please locate where 'locate' occurs!";
            let pos = str.indexOf("locate");        // 7
        JS counts positions from zero (0)
        The `lastIndexOf()` method returns the index of the last occurence of a specified text in a string.
            let str = "Please locate where 'locate' occurs!";
            let pos = str.lastIndexOf("locate");    // 21
        Both `indexOf()` and `lastIndexOf()` return -1 if the text is not found.
            let str = "Please locate where 'locate' occurs!";
            let pos = str.lastIndexOf("John");    // -1 
        Both methods accept a second parameter as the starting position for the search:
            let str = "Please locate where 'locate' occurs!";
            let pos = str.indexOf('locate", 15);    // 21
        The `lastIndexOf()` method searches backwards (from the end to the beginning), meaning: if the second parameter is `15`, the search starts at position 15, and searches to the beginning of the string.
            let str = "Please locate where 'locate' occurs!";
            let pos = str.lastIndexOf("locate", 15);    // 7

    - Searching for a String in a String 
        The `search()` method searches a string for a specified value and returns the position of the match:
            let str = "Please locate where 'locate' occurs!";
            let pos = str.search("locate");         // 7
        
    - The indexOf() and search() method are NOT equal
        The search() method cannot take a second start position argument.
        The indexOf() method cannot take powerful search values (regular expressions).

    - Extracting string parts 
        There are 3 methods for extracting a part of a string:

            The slice() Method: `slice(start, end)`
                `slice()` extracts a part of a string and returns the extracted part in a new string.
                This method takes two paramenters:
                    The start position 
                    The end position (end not included)
                        let str = "Apple, Banana, Kiwi";
                        let res = str.slice(7, 13);         // Banana
                    If a parameter is negative, the position is counted from the end of the string.
                        let str = "Apple, Banana, Kiwi";
                        let res = str.slice(-12, -6);       // Banana
                    If you omit the second parameter, the method will slice out the rest of the string:
                        let str = "Apple, Banana, Kiwi";
                        let res = str.slice(7);             // Banana, Kiwi 

                        let str = "Apple, Banana, Kiwi";
                        let res = str.slice(-12);           // Banana, Kiwi 

            The substring() Method: `substring(start,end)`
                Similar to slice(), however, substring() cannot accept negative indexes.
                    let str = "Apple, Banana, Kiwi";
                    let res = str.substring(7, 13);             // Banana
                If you omit the second parameter, substring() will slice out the rest of the string.

            The substr() Method: `substr(start, length)`
                Similar to slice(), however, the second parameter specifies the length of the extracted part.
                    let str = "Apple, Banana, Kiwi";
                    let res = str.slice(7, 6);             // Banana
                If you omit the second parameter, substr() will slice out the rest of the string.
                    let str = "Apple, Banana, Kiwi";
                    let res = str.slice(7);             // Banana, Kiwi 
                If the first parameter is negative, the position counts from the end of the string.
                    let str = "Apple, Banana, Kiwi";
                    let res = str.slice(-4);             // Kiwi 

    - Replacing string content 
        The replace() method replaces a specified value with another value in a string:
            str = "Please visit Microsoft!";
            let n = str.replace("Microsoft", "W3Schools");      // Please visit W3Schools!
        
        THE replace() METHOD DOES NOT CHANGE THE STRING IT IS CALLED ON. IT RETURNS A NEW STRING.
        
        By default, the replace() method replaces ONLY THE FIRST MATCH.
            str = "Please visit Microsoft and Microsoft!";
            let n = str.replace("Microsoft", "W3Schools");      // Please visit W3Schools and Microsoft!
        
        By default, the replace() method is CASE SENSITIVE
            str = "Please visit Microsoft!";
            let n = str.replace("MICROSOFT", "W3Schools");      // Please visit Microsoft!

        To replace case insensitive, use a regular expression with an `/i` flag (insensitive):
            str = "Please visit Microsoft!";
            let n = str.replace(/MICROSOFT/i, "W3Schools");     // Please visit W3Schools!
                NOTE THAT REGULAR EXPRESSIONS ARE WRITTEN WITHOUT QUOTES

        To replace ALL MATCHES, use a regular expression with a `/g` flag (global match):
            str = "Please visit Microsoft and Microsoft!";
        let n = str.replace(/MICROSOFT/g, "W3Schools");         // Please visit W3Schools and W3Schools!

    - Converting to Upper and Lower Case
        `toUpperCase()` converts a string to upper case:
            let text1 = "Hello World!";
            let text2 = text1.toUpperCase();  // HELLO WORLD!
        `toLowerCase()` converts a string to lower case:
            let text1 = "Hello World!";
            let text2 = text1.toLowerCase();  // hello world!
    
    - The concat() Method
        `concat()` joins two or more strings:
            let text1 = "Hello";
            let text2 = "World";
            let text3 = text1.concat(" ", text2);       // Hello World 
                // This method takes text1, adds a space (" "), then adds text2
        The `concat()` method can be used instead of the plus operator. 
            These two lines do the same thing:
                let text = "Hello" + " " + "World!";
                let text = "Hello".concat(" ", "World!");
        
    ALL STRING METHODS RETUNR A NEW STRING. THEY DON'T MODIFY THE ORIGINAL STRING.
        Formally said: Strings are immutable - they cannot be changed, only replaced.

    - String.trim()
        The `trim()` method removes whitespace from both sides of a string:
            let str = "          Hello World!         "
            alert(str.trim());          // Hello World!
        THE trim() METHOD IS NOT SUPPORTED IN IE 8 OR Lower
            If you need to support IE 8 , you can use `replace()` with a regular expression instead:
                let str = "       Hello World!        ";
                alert(str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''));
            You can also use the replace solution above to add a trim function to the JS `String.prototype`:
                if (!String.prototype.trim) {
                    String.prototype.trim = function() {
                        return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
                    };
                }
                let str = "             Hello World!             ";
                alert(str.thrim());
    
    - Extracting String Characters
        There are 3 methods for extracting string Characters:
            The `charAt()` method returns the character at a specified index (position) in a string:
                let str = "HELLO WORLD";
                str.charAt(0);              // returns H 
            The `charCodeAt()` method returns the unicode of the character a the specified index in a string:
                The method returns a UTF-16 code (an integer between 0 and 65535)
                    let str = "HELLO WORLD";
                    str.charCodeAt(0);      // returns 72
            Property Access []
                ECMAScript 5 (2009) allows property access [] on strings:
                    let str = "HELLO WORLD";
                    str[0];                 // returns H 
                PROPERTY ACCESS MIGHT BE A LITTLE UNPREDICTABLE:
                    It does not work in IE 7 or earlier
                    It makes strings look like arrays (THEY ARE NOT)
                    If no character is found, [] returns undefined, while charAt() returns an empty string
                    It is read only. str[0] = "A" give no error (but does not work!)
                        let str = "HELLO WORLD";
                        str[0] = "A";               // give no error, but does not work
                        str[0];                     // returns H
    
    IF YOU WANT TO WORK WITH A STRING AS AN ARRAY, YOU CAN CONVERT IT TO AN ARRAY.
    - Converting a string to an Array
        The `split()` Method is used to convert a string into an array.
            let txt = "a,b,c,d,e";          // string 
            txt.split(",");                 // split on commas
            txt.split(" ");                 // split on spaces 
            txt.split("|");                 // split on pipe 
        If the SEPARATOR IS OMITTED, the returned array will contain the whole string in index [0].
        If the SEPARATOR IS "", the returned array will be an array of single characters.
            let txt = "Hello";              // string 
            txt.split("");                  // split in characters 
    
    - Complete string reference 
        For a complete reference, go to https://www.w3schools.com/jsref/jsref_obj_string.asp
            The reference contains descriptions and examples of all string properties and methods.

        For an exhaustive list of methods that can be used on strings, go to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String



/* Conditionals */
    - Comparisons 
        We know many comparison operators from maths.
        In JS they are written like this:
            Greater/less than: a > b, a < b
            Greater/less than or equals: a >= b, a <= b
            Equals: a == b   Please note the double equality sign means the equality test while a single = means assignment. 
            Not equals: a != b

    - Boolean is the result
        ALL COMPARISON OPERATORS RETURN A BOOLEAN VALUE 
            true - means "yes", "correct" or "the truth"
            false - means "no", "wrong" or "not the truth"
                alert( 2 > 1 );     // true (correct)
                alert( 2 == 1 );    // false (wrong)
                alert( 2 != 1 );    // true (correct)
        A comparison result can be assigned to a varialbe, just like any value:
            let result = 5 > 4; // assign the result of the comparison
            alert ( result );   // true
    
    - String comparison
        To see whether a string is great than another, JS uses the so-called "dictionary" or "lexicographical" order. 
        STRINGS ARE COMPARED LETTER-BY-LETTER
            alert( 'Z' > 'A' );         // true
            alert( 'Glow' > 'Glee' );   // true
            alert( 'Bee' > 'Be' );      // true
        The algorithm to compare two strings is simple:
            1. Compare the first character to both strings.
            2. If the first character from the first string is greater (or less) than the other string's, then the first string is greater (or less) than the second. We're done.
            3. Otherwise, if both strings' first characters are the same, compare the second characters the same way.
            4. Repeat until the end of either string.
            5. If both strings end at the same length, then they are equal. Otherwise, the longer string is greater.
                Not a real dictionary, but Unicode order    
                    The comparison algorithm given above is roughly equivalent to the one used in dictionaries or phone books, but it's not exactly the same. 
                    For instance, case matters. A capital letter 'A' is not equal to the lowercase 'a'. Which one is greater? The lowercase 'a', because the lowercase character has a greater index in the internal encoding table JS uses (Unicode). 
    
    - Comparison of different types 
        When comparing values of different types, JS converts the values to numbers.
            alert( '2' > 1 );       // true, string '2' becomes a number 2
            alert( '01' == 1 ):     // true, string '01' becomes the number 1
        For bolean values, `true` becomes '1' and `false` becomes '0'
            alert( true == 1 );     // true
            alert( false == 0 );    // true
        IT IS POSSIBLE THAT AT THE SAME TIME:   
            Two values are equal
            One of them is `true` as a boolean and the other one is `false` as a boolean 
                let a = 0;
                alert( Boolean(a) );        // false
                let b = "0";
                alert( Boolena(b) );        // true
                alert( a == b );            // true
                    - From the JS standpoint, this result is quite normal. An equality check converts values using the numeric conversion (hence "0" becomes 0), while the explicit Boolean conversion uses another set of rules. 
    
    - Strict equality 
        A regular equality check == has a problem. It cannot differentiate 0 from `false`.
            alert ( 0 == false );       // true 
        The same thing happens with an empty string:
            alert( '' == false );       // true
        This happens because operands of different types are converted to numbers by the equaltiy operat ==. An empty string, just like `false`, becomes a 0.
        To differentiate `0` from `false`, a STRICT EQUALITY OPERATOR `===` checks the equality without type conversion.
            In other words, if a and b are of different types, then `a === b` immediately returns `false` without an attempt to convert them. 
                alert( 0 === false );       / false, because the types are different 
            There is also a "strict non-equality" operator `!==` analogous to `!=`
                The strict equalty operator is a bit longer to write, but makes it obvious what's going on and leaves less room for errors. 
    
    - Comparison with null and undefined 
        There's a non-intuitive behavior when `null` or `undefined` are compared to other values. 
        For a strict quality check `===`
            These values are differen, becaue each of them is a different type:
                alert( null === undefined );        // false
        For a non-strict check `==`
            There's a speacial rule. These two are a "sweet couple": they equal each other ( in the sense of `==`), but not any other value. 
                alert( null == undefined );         // true 
        For maths and other comparisons `< > <= >=`
            `null/undefined` are converted to numbers: `null` becomes `0`, while undefined becomes `NaN`
            Funny things happen when we apply these rules. Also, how not to fall into a trap with them.
                Strange result: null vs 0
                    alert( null > 0 );      // false (1)
                    alert( null == 0 );     // false (2)
                    alert( null >= 0 );     // true (3)
                    Mathematically, that's strange. The last result states that `null` is greater than or equal to zero, meaning one of the other comparisons should also be true, but they are not. 
                        (1, 3) An equality check `==` and comparisons `> < >= <=` work differently. Comparisons convert `null` to a number, treating it as `0`. That is why `null >= 0` is true and `null > 0` is false. 
                        (2) On the other hand, the equality check `==` for `undefined` and `null` is defined such that, without conversions, they equal each other and don't equal anything else. That's why `null == 0` is false.
                An incomparable undefine 
                    The value `undefined` shouldn't be compared to other values: 
                        alert( undefined > 0 );         // false (1)
                        alert( undefined > 0 );         // false (2)
                        alert( undefined == 0 );        // false (3)
                    Comparison (1) and (2) return `false` because `undefined` gets converted to `NaN` and `NaN` is a special numeric value which returns `false` for all comparisons 
                    The equality check (3) returns `false` because `undefined` only equals `null`, `undefined`, and no other value. 
                Avoid problems
                    These tricky things will gradually become familiar over time, but there's a solid way to avoid problems with them:
                        Treat any comparison with `undefined/null` except the stric equality `===` with exceptional care.
                        Don't use comparision `>= > < <=` with a variable which may be `null/undefined`, unless you're really sure of hat you're doing. If a variable can have these values, check for them separately.
    
    - Summary
        Comparison operators return a boolean value.
        Strings are compared letter-by-letter in the "dictionary" order
        When values of different types are compared, they get converted to numbers (with the exclusion of a strict equality check).
        The values `null` and `undefined` equal (==) each other and do not equal any other value.
        Be careful when using comparisons like `>` or `<` with variables that can occasionally be `null/undefined`. Checking for `null/undefined` separately is a good idea. 



/* Conditional if else / else if Statements */
    Conditional statments are use to perform different actions for different decisions
    JS uses the following conditional statements:
        Use `if` to specify a block of code to be executed, if a specified condition is true 
        Use `else` to specify a block of code to be executed, if the same condition is false 
        Use `else if` to specify a new condition to test, if the prior condition is false 
        Use `switch` to specify many alternative blocks of code to be executed 

    - The if Statement
            if (condition) {
                // block of code to be executed if the condition is true 
            }
        Specifies a block of JS code to be executed if a condition is true.
            if (hour < 18) {
                greeting = "Good day";
            }       // Good day 
    
    - The else Statement 
            if (condition) {
                // block of code to be executed if the condition is true 
            } else {
                // block of code to be executed if the condition is false 
            }
        Specifies a block of code to be executed if the condition is false.
            if (hour < 18) {
                greeting = "Good day";
            } else {
                greeting = "Good evening";  
            }       // Good evening 
    
    - The else Statement    
            if (condition1) {
                // block of code to be exectued if conditional is true 
            } else if (condition2) {
                // block of code to be executed if condition1 is false and condition2 is true 
            } else {
                // block of code to be executed if condition1 is false and condition2 is false 
            }
        Specifies a new condition if the first condition is false.
            if (time < 10) {
                greeting = "Good morning";
            } else if {
                greeting = "Good day";
            } else {
                greeting = "Good evening";
            }



/* Logical operators */
    There are three logical operators in JS: `||` (or), `&&` (and), `!` (not)
    Although they are called "logical", they can be applie to values of any type, not only boolean. 
    Their result can also be of any type.

    - || (OR)
        The OR operator is represented with two vertical line symbols 
            result a || b;
        In classical programming, the logical OR is meant to manipulate boolean values only. If any of its arguments are `true`, tis returns `true`, otherwise it returns `false`.
        In JS, the operator is a little bit trickier and more powerful. 

        There are four possible logical combinations:
            alert( true || true );      // true
            alert( false || true );     // true 
            alert( true || false );     // true 
            alert( false || false );    // false 
        As can be seen the result is always `true` except for the case when both operands are `false`.
        If an operand is not boolean, it's converted to a boolean for the evaluation. 
            For instance, the number `1` is treated as `true`, the number `0` as false:
                if (1 || 0) {                   // works just like if( true || false )
                    alert( 'truthy!' ); 
                }
        Most of the time, OR `||` is used in an `if` statement to test if ANY of the given conditions is `true`
            let hour = 9;
            if (hour < 10 || hour > 18) {
                alert( 'The office is closed.' );
            }
        You can "extend", pass multiple conditions, in an OR statment:
            let hour = 12;
            let isWeekend = true;
            if (hour < 10 || hour > 18 || isWeekend) {
                alert( 'The office is close.' );
            }
        The logicals described above are somewhat classical. What follows are the 'extra' features of JS.

    - || (OR) finds the truthy value 
        The extended algorithm works as follows:
            result = value1 || value2 || varlue3;
            The OR `||` operator does the following:
                Evaluates operands from left to right
                For each operand, converts it to boolean. If the result is `true`, stops and returns the original value of that operand.
                If all operands have been evaluated (ie all were `false`), returns the last operand.
        A value is returned in its original form, without the conversion
            In other words, a chain of OR `||` returns the first truthy value or the last one if no truthy value is found.
                alert( 1 || 0 );                    // 1 (1 is truthy)
                alert( null || 1 );                 // 1 (1 is the first truthy value)
                alert( null || 0 || 1 );            // 1 (the first truthy value)
                alert( undefined || null || 0 );    // 0 (all falsy, returns the last value)
            This leads to some interesting usage compared to a "pure, classical, boolean-only OR"
                1) Getting the first turhty value from a list of variables or expressions  
                    For instance, we have `firstName`, `lastName` and `nickName` variables, all optional.
                    Let's use OR || to choose the one that has the data and show it (or `anonymous` if nothing set):
                        let firstName = "";
                        let lastName = "";
                        let nickName = "SuperCoder";
                        alert( firstName || lastName || nickName || "Anonymous" );      // SuperCoder 
                    If all of the variables were falsy, "Anonymous" would show up.
                2) Short-circuit evaluation
                    Another feature of OR || operator is the so-called "short-circuit" evaluation 
                    It means that || processes its arguments until the first truthy value is reached, and then the value is returned immediately, without even touching the other argument. 
                    That importance of this feature becomes obvious if an operand isn't just a value, but an expression with a side effect, such as a variable assignment or a function call. 
                        true || alert("not printed");
                        false || alert("printed");
                            In the above example, only the second message is printed ( "printed" )
                            In the first line, the OR || operator stops the evaluation immediately upon seeing `true`, so the `alert` isn't run. 
                    Sometimes, people use this feature to execute commands only if the condition on the left part is falsy.
    
    - && (AND)
        The AND operator is represented with two ampersands `&&`:
            result = a && b;
        In classical programming, AND returns `true` if both operands are truthy and `false` otherwise:
            alert( true && true );          // true
            alert( false && true );         // false 
            alert( true && false );         // false
            alert( false && false );        // false 
        An example with `if`:
            let hour = 12;
            let minute = 20;
            if (hour == 12 && minute == 30) {
                alert( 'The time is 12:30' );
            }
        Just as with OR, any value is allowed as an operand of AND:
            if (1 && 0) {                                               // evaluated as true && false 
                alert( "won't work, because the result is falsy" );
            }
    
    - AND `&&` finds the first false value 
        Given multiple AND'ed values:
            result = value1 && value 2 && value3;
        The AND `&&` operator does the following:
            Evaluates operands from left to right 
            For each operand, converts it to a boolean. If the result is `false`, stops and returns the origina value of that operand.
            If all operands have been evaluated (ie all were truthy), returns the last operand 
        AND returns the first falsy value or the last value if none were found 
            The rules above are similar to OR. The difference is that AND returns the first falsy value while OR returns the first truthy value. 
                // if the first operand is truthy, AND returns the second operand
                alert( 1 && 0 );        // 0
                alert( 1 && 5 );        // 5

                // if the first operand is falsy, AND returns it. The second operand is ignored
                alert( null && 5 );                 // null 
                alert( 0 && "no matter what" );     // 0

            We can also pass several values in a row, as below. Notice how the first falsy is returned:
                alert( 1 && 2 && null && 3 );       // null
            When all values are truthy, the last value is returned:
                alert( 1 && 2 && 3 );               // 3, the last value 

        Precedence of AND `&&` is higher than OR `||`
            The code `a && b || c && d` is essentially the same as if the `&&` expressions were in parentheses: 
                    `( a && b || c && d )`
        Don't replayce `if` with `||` or `&&`
            Sometimes, people use the AND `&&` operator as a "shorter to write `if`"
                    let x = 1;
                    (x > 0) && alert( 'Greater than zero!' );
                The above expression is analogous to the expression below:
                    let x = 1;
                    if (x > 0) {
                        alert( 'Greater than zero!' );
                    }
            Although the variant with `&&` appears shorter, `if` is more obvious and tends to be a little bit more readable.
            It is recommended to use every construct for its purpose: use `if` if we want if and use `&&` if we want AND.
    
    - ! (NOT)
        The boolean NOT operator is represented with an exclamation sign (!)
            result = !value;
        The operator accepts a single argument and does the following:
            1. Converts the operand to boolean type: `true/false`
            2. Returns the inverse value 
            Example 
                alert( !true );         // false 
                alert( !0 );            // true 
        A double NOT `!!` is sometimes used for converting a value to boolean type
                alert( !!"non-empty string" );  // true 
                alert( !!null );                // false 
            That is, the first NOT converts the value to boolean and returns the inverse, and the second NOT inverses it again. In the end, we have a plain value-to-boolean conversion.
        The built-in `Boolean` fuction is a more verbose way to do the same thing:
            alert( Boolean("non-empty string") );       // true 
            alert( Boolean(null) );                     // false 
        The precendence of NOT `!` is the highest of all logical operators, so it always executes first, before `&&` or `||`

    - Additional Examples 
        alert( null || 2 || undefined );
            // 2 - the first truthy value 

        alert( alert(1) || 2 || alert(3) );
            // first 1, then 2 
                The call to `alert` does not retun a value. In other words, it returns `undefined`
                    1. The first OR `||` evaluates its left operand `alert(1)`. This shows the first message with `1`.
                    2. The `alert` returns `undefined`, so OR goes on to the second operand searching for a truthy value.
                    3. The second operand `2` is truth, so the execution is halted, `2` is returned and then shown by the outer alert.
                There will be no `3`, because the evaluation does not reach `alert(3)`
        
        alert( 1 && null && 2);
            // null - because it's the first falsy value from the list 

        alert( alert(1) && alert(2) );
            // 1, and then undefined 
                The call to `alert` returns `undefined` (it just shows a message, so there's no meaningful return).
                Because of that, `&&` evaluates the left operand (outputs `1`), and immediately stops, because `undefined` is a falsy value. And `&&` looks for a falsy value and returns it, so it's done. 

        alert( null || 2 && 3 || 4 );
            // 3 
                The precedence of AND `&&` is higher than `||`, so it executes first.
                The expression becomes: `null || 3 || 4`
                The result is the first truthy value 
        
        Write an 'if' condition to check that `age` is between `14` and `90` inclusively ("inclusively" means that `age` can reach the edges of `14` and `90`)
            if ( age >= 14 && age <= 90 );
            
        Write an 'if' condition to check that `age` is NOT between `14` and `90` inclusively 
            if ( !( age >= 14 && age <= 90 ) );
                or 
            if ( age < 14 || age > 90 );
        
        Which of the following `alert`s are going to execute and what will the restult be?
            if (-1 || 0) alert( 'first' );                  // executes, result = 'first'       -1 || 0 = -1, truthy
            if (-1 && 0) alert( 'second' );                 // doesn't execute,                 -1 && 0 = 0, falsy  
            if (null || -1 && 1) alert( 'third' );          // executes,                        null || 1 = 1, truthy  

            
        Check the login
            let userName = prompt("Who's there?", '');

            if (userName == "Admin") {

                let password = prompt("Please enter your password", '');
        
                if (password == "TheMaster") {
                    alert( "Welcome!" );
                } else if (password == '' || password == null) {
                    alert( "Cancelled" );
                } else {
                    alert( "Wrong password" );
                }
            
            } else if (userName == '' || userName == null) {
                alert( "Cancelled" );
            } else {
                alert( "I don't know you" );
            }



/* Conditional examples using HTML & JS */

    - Multiple `if() {} else {}` statement for weather
        
        <label for="weather"> Select the weather type today: </label>
        <selet id="weather">
            <option value=""> -- Make a choice -- </option>
            <option value="sunny"> Sunny </option>
            <option value="rainy"> Rainy </option>
            <option value="snowing"> Snowing </option>
            <option value="overcast"> Overcast </option>
        </select>

        <p></p>


        cont select = document.querySelector('select');
        const para - document.querySelector('p');

        select.addEventListener('change', setWeather);

        function setWeather() {
            const choice = select.value;

            if(choice === 'sunny') {
                para.textContent = 'It is nice and sunny outside today. Wear shorts! Got to the beach!';
            } else if (choice === 'rainy') {
                para.textContent = 'Rain is falling outside. Don't forget your raincoat!';
            } else if (choice === 'snowing') {
                para.textContent = 'Snow is falling! Don't forget your hat!';
            } else if (choice === 'overcase') {
                para.textContent = 'It's a glooming day. Bring an umbrella, just in case.';
            } else {
                para.textContent = '';
            }
        }

    - Any value that is not `false`, `undefined`, `null`, `0`, `NaN`, or an empty string ('') actually returns `true` when tested as a conditional statement, therefore you can simply use a variable name on its own to test whether it is `true`, or even that it exists (that is, not undefined).
        
        let cheese = 'Cheddar';

        if (cheese) {
            console.log('Yay! Cheese available for making cheese on toast.');
        } else {
            console.log('No cheese on toast for you today.');
        }

    - Another example where one does not need to explicityly specify '=== true'

        let shoppingDone = false;

        if (shoppingDone) {                 // no need to explicitly specify '=== true'
            let childsAllowance = 10;
        } else {
            let childsAllowance = 5;
        }

    - Nesting if...else statments inside one another 
        
        if (choice === 'sunny') {
            if (temperature < 86) {
                para.textContent = 'It is ' + temperature + ' degrees outside - nice and sunny.';
            } else if (temperature >= 86) {
                para.textContent = 'It is ' + temperature + ' degree outside - REALLY HOT!;
            }
        }

        // Even though the code all works together, each if...else statement works completely independent of each other.

    - You could write the `'sunny' + temperature` code using && (AND)

        if (choice === 'sunny' && temperature is < 86) {
            para.textContent = 'It is ' + temperature + ' degrees outside - nice and sunny.';
        } else if (choice === 'sunny' && temperature is >= 86) {
            para.textContent = 'It is ' + temperature + ' degree outside - REALLY HOT!;
        }

    - A || (OR) conditional

        if (iceCreamTruckOutside || houseStatus === 'on fire') {
            console.log('You should leave the house quickly.');
        } else {
            console.log('Probably should just stay in then.');
        }

    - To write the previous if...else using a != (NOT)

        if (!(iceCreamTruckOutised || houseStatus === 'on fire')) {
            console.log('Probably should just stay in then.');
        } else {
            console.log('You should leave the house quickly.');
            )
        }

    - You can combine as many logical statements together as you want to

        if ((x === 5 || y > 3 || z <= 10) && (loggedIn || userName === 'Steve')) {
            // run the code 
        }

        To make this work you MUST specify a complete test on either side of each OR operator.

    - 



/* switch Statements */ 
    - Good for cases where you want to set a variable to a certain choice of value or print out a particular statement depending on a condition, especially if you've got a large number of choices.
    - Switch statements take a single expression/value as an input, then look through a number of choices until they find one that matches that value, executing the corresponding code that goes along with it.
            switch (expression) {
                case choice1:
                    run this code
                    break;
                
                // include as many cases as you like 

                default:
                    run this code is no cases are met
            }
        1. The keyword `switch`, followed by a set of parentheses.
        2. An expression or value inside the parentheses.
        3. The keyword `case`, followed by a choice that the expression/value could be, followed by a colon.
        4. Some code to run if the choice matches the expression.
        5. A `break` statement, followed by a semi-colon. If the previous choice matches the expression/value, the browser stops exectuing the code block here and moves on to any code that appears below the swith statement.
        6. As many other cases (bullets 3-5) as you like.
        7. The keyword `default`, followed by exactly the same code pattern as one of the cases (bullets 3-5), except that `default` does not have a choice after it, and you don't need to `break` statment as there is nothing to run after this in the block anyway. This is the default option that runs if none of the choices match.
            * You don't have to include the `default` section. you can safely omit it if there is no chance that the expression could end up equaling an unknown value. However, if there is a chance of this, you need to include it to handle unkonwn cases. 
    
        Switch example:
            <label for="weather"> Select the weather type today: </label>
            <select id="weather">
                <option value=""> -- Make a choice -- </option>
                <option value="sunny">Sunny</option>
                <option value="rainy">Rainy</option>
                <option value="snowing">Snowing</option>
                <option value="overcast">Overcast</option>
            </select>

            <p></p>


            const select = document.querySelector('select');
            const para = document.querySelector('p');

            select.addEventListener('change', setWeather);

            fuction setWeather() {
                const choice = select.value;

                switch (choice){
                    case 'sunny':
                        para.textContent = 'It's a sunny day. Let's go to the beach!';
                        break;
                    case 'rainy':
                        para.textContent = 'It's a rainy day. Let's stay on the couch and watch movies!';
                        break;
                    case 'snowing';
                        para.textContent = 'It's snowing! Let's make a snowman!';
                        break;
                    case 'overcast';
                        para.textContent = 'Tut tut. Looks like rain. Don't forget your umbrella!';
                        break;
                    default:
                        para.textContent = '';
                }
            }

    - Using a switch statement in JS
        The following is a working example of a `switch` statement. In this code block, we will find the current day of the week with the `new Date()` method, and `getDay()` to print a number corresponding to the current day. `1` stands for Monday, all the way through `7` which stands for Sunday. We'll start by setting up our variable.
            
            const day = new Date().getDay();

        Using `switch`, we will send a message to the console each day of the week. The program will run in order from top to bottom looking for a match and once one is found, the `break` command will halt the `switch` block from continuing to evaluate statements.

            // Set the current day of the week to a variable, with 1 being Monday and 7 being Sunday 
            const day = new Date().getDay();

            switch (day) {
                case 1:
                    console.log("Happy Monday!");
                    break;
                case 2:
                    console.log("It's Tuesday! You got this!");
                    break;
                case 3:
                    console.log("Hump Day!");
                    break;
                case 4:
                    console.log("Thirsty Thursday! Save me a pint!");
                    break;
                case 5:
                    console.log("TGIF!");
                    break;
                case 6:
                    console.log("Hoy se bebe para hoy es Sabado Gigante!");
                    break;
                case 7:
                    console.log("I need a day off!");
                    break;
                default:
                    console.log("Are we back in quarantine?");
            }

        Depending on the day of the week, your output will be different. We included a `default` block at the end to run in case of an error, which in this case should not happen as there are only 7 days of the week. We could also have only printed results for Monday to Friday and used the `default` block to show the same message through the weekend. 

        * If we had omitted the `break` keyword in each statement, none of the other `case` statements would have evaluated to true, but the proram would have continued to check until it reached the end. In order to make our programs faster and more efficient, we include the `break`.

    - Switch Ranges
        To evaluate a range of values in a `switch` block, set the expression to `true` and do an operation within each `case` statement. 

        To demonstrate, we will make a simple grading app which will take a number score and convert it to a letter grade, with the following requirements:
            Grade of 90 and above = A
            Grade of 80 to 89 = B
            Grade of 70-79 = C 
            Grade 60-69 = D 
            Grade 59 or below = F 

        Now we can write that as a `switch` statement. Since we're checking a range, we will perform the operation in each `case` to check if each expression is evaluating to `true` then break out of the statement once the requirments for `true` have been satisfied.

            // Set the student's grade
            const grade = 87

            switch (true) {
                // If score is 90 or greater 
                case grade >= 90:
                    console.log('A');
                    break;
                // If score is 80 or greater 
                case grade >= 80:
                    console.log('B');
                    break;
                // If score is 70 or greater
                case grade >= 70:
                    console.log('C');
                    break;
                // If score is 60 or greater
                case grade >= 60:
                    console.log('D');
                    break;
                // If score is below 60
                default:
                    console.log('F');
                    break;
            }

        The expression in parentheses to be evaluated is `true` in this example. This means that any `case` that evaluates to `true` will be a match.
        Just like with `else if`, `switch` is evaluated from top to bottom, and the first true match will be accepted. Terefore, even though our `grade` variable is `87` and therefore evaluates to `true` for C and D as well, the first match is B, which will be the output. 

    - Multiple Cases with the same output 
        You may encounter code in which multiple cases should have the same output. In order to accomplish this, you can use more than one case for each block of code.

        This will be shown by creating an application matching the current month to the appropriate season. First, we will use the `new Date()` method to find a number corresponding to the current month, and apply that to the `month` variable. 

            const month = new Date().getMonth();

        The `new Date().getMonth()` method will output a number from 0 to 11, with 0 being January and 11 being December. Our application will then output the four seasons with the following specifications for simplicity:
            Winter: January, February and March
            Spring: April, May and June 
            Summer: July, August and September 
            Fall: October, November and December 

        The following is the code for the season application: 

            // Get number corresponing to the current month, with 0 being January and 11 being December 
            const month = new Date().getMonth();

            switch(month) {
                // January, February, March 
                case 0:
                case 1:
                case 2:
                    console.log('Winter');
                // April, May, June 
                case 3:
                case 4:
                case 5:
                    console.log('Spring');
                // July, August, September 
                case 6:
                case 7:
                case 8:
                    console.log('Summer');
                // October, November, December 
                case 9:
                case 10:
                case 11:
                    console.log('Fall');
                default:
                    console.log('Invalid Month');
            }



/* Ternary operator */
    - The ternary or conditional operator is a small bit of syntax that tests a condition and returns one value/expression if it is `true`, and another if it is `false`. This can be useful in some situations, and can take up a lot less code than an if...else block if you simply have two choices that are chosen between via a `true`/`false` condition. 
            
            ( condition ) ? run this code : run this code instead 

            let greeting = ( isBirthday ) ? 'Happy birthday! We hope you have a great day!' : 'Good morning!'
        
        In the above example, there is a variable `isBirthday`. If `isBirthday` is `true`, we give our guest a happy birthday message; if not, we give her the standard daily greeting. 

    - The following example shows a simple theme chooser where the styling for the site is applied using a ternary operator.
            <label> for="theme">Select theme: </label>
            <select id="theme">
                <option value="white">White</option>
                <option value="black">Black</option>
            </select>

            <h1>This is my website</h1>


            const select = document.querySelector('select');
            const html = document.querySelector('html');
            document.body.style.padding = '10px';

            function update(bgColor, textColor) {
                html.style.backgroundColor = bgColor;
                html.style.color = textColor;
            }

            select.onchange = function() {
                ( select.value === 'black' ) ? update('black', 'white') : update('white', 'black');
            }

        Here we've got a <select> element to choose a theme (black or white), plus a simple <h1> to display a website title. We also have a function called update(), which takes two colors as parameters (inputs). The website's background color is set to the first provided color, and its text color is set to the second provided color. 
        Finally, we've also got an `onchange` event listener that serves to run a function containing a ternary operator. It starts with a test condition - `select.value === 'black'`. If this returns `true`, we run the `update()` function with parameters of black and white, meaning that we end up with background color of black and text color of white. If it returns `false`, we run the `update()` function with parameters of white and black, meaning that the site colors are inverted. 

    - `if...else if... else` ternary operators can be written using the question mark operator (?)
            let age = prompt('age?', 18);

            let message = (age < 3) ? 'Hi, baby!' :
                (age < 18) ? 'Hello!' :
                (age < 100) ? 'Greetings!' :
                'What an unusual age!' ;

            alert( message ); 



/* Active Learning Exercises */
    - Active learning: A simple calendar
            <label for="month">Choose a month: </label>
            <select id="month">
                <option value="january">Enero</option>
                <option value="february">Febrero</option>
                <option value="march">Marzo</option>
                <option value="april">Abril</option>
                <option value="may">Mayo</option>
                <option value="june">Junio</option>
                <option value="july">Julio</option>
                <option value="august">Agosto</option>
                <option value="september">Septembre</option>
                <option value="october">Octubrey</option>
                <option value="november">Noviembre</option>
                <option value="december">Diciembre</option>
            </select>

            <h1></h1>


            const select = document.querySelector('select');
            const list = document.querySelector('ul');
            const h1 = document.querySelector('h1');

            select.onchange =  function() {
                const choice = select.value;
                let days = 31;
                if (choice === 'february') {
                    days = 28;
                } else if (choice === 'april' || choice === 'june' || choice === 'september' || choice === 'november') {
                    days = 30;
                }
            
            createCalendar(days, choice);
            }

            function createCalendar(days, choice){
                list.innerHTML = '';
                h1.textContent = choice;
                for(let i = 1; 1 <= days, i++){
                    const listitem = document.createElement('li');
                    listitem.textContent = i;
                    list.appendChild(listitem);
                }
            }

            
    - Active learning: Color choices 
            <label for="theme">Choose a theme: </label>
                <select id="theme">
                    <option value="white">White</option>
                    <option value="black">Black</option>
                    <option value="purple">Purple</option>
                    <option value="yellow">Yellow</option>
                    <option value="psychedelic">Psychedelic</option>
                </select>

            <h1>This is my website</h1>

            const choice = querySelector('select');
            const html = querySelector('html');
            document.body.style.padding = '10px';

            select.onchange = function() {
                const choice = select.value;

                switch(choice){
                    case 'white':
                        update('white','black');
                        break;
                    case 'black':
                        update('black','white');
                        break;
                    case 'purple':
                        update('purple','white');
                        break;
                    case 'yellow':
                        update('yellow','darkgray');
                        break;
                    case 'psychedelic':
                        update('lime','purple');
                        break;
                }
            }

            function update(bgColor, textColor) {
                html.style.backgroundColor = bgColor;
                html.style.color = textColor;
            }
            


/* JS Functions */
    - Built-in Functions    
        // the replace() string function takes a source string, and a target string and replaces the source string, with the target string, and returns the newly formed string 
                let myText = 'I am a string';
                let newString = myText.replace('string', 'sausage');        // replaces the word 'string' with 'sausage'
                consol.log(newString);

        // the join() function takes an array, joins all the array items together into a single string, and returns this new string 
                let myArray = ['I', 'love', 'chocolate', 'frogs'];
                let madeAString = myArray.join(' ');                        // joins all of the strings to a single string 
                console.log(madeAString);

        // the random() function generates a random number between 0 and up to but not including 1, and returns that number 
                let myNumber = Math.random();

        The JavaScript language has many built-in functions to allow you to do usefull things without having to write all that code yourself. In fact, some of the code you are calling when you invoke a built in browser function couldn't be written in JavaScript - many of these functions are calling parts of the background browser code, which is written largely in low-level system languages like c++, not web languages like JavaScript.

        Bear in mind that some built-in browser functions are not part of the core JavaScript language - some are defined as part of browser APIs, which build on top of the default language to provide even more functionality 
            (https://developer.mozilla.org/en-US/Learn/JavaScript/First_steps/What_is_JavaScript#So_what_can_it_really_do)

    - Functions versus methods 
        Programmers call functions that are part of objects methods. 
            The built-in code we've made use of so far camein both forms: functions and methods. You can check a full list of the built-in functions, as well as the built-in objects and their corresponding methods (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects)

            You've also seen a lot of custom functions in the course so far - functions defined in your code, not inside the browser. Anytime you saw a custom name with parentheses straight after it, you were using a custom fucntion. 

            Functions can contain whatever code you like - you can even call other functions from inside functions.

    - Invoking functions
        In order to use a function after it has been defined, you've got to run, or invoke, it. This is done by including the name of the function in the code somewhere, followed by parentheses.

                function myFunction() {
                    alert('hello');
                }

                myFunction();               // calls the function once 
        
    - Anonymous functions 
        You may see functions defined and invoked in slightly different ways.

        Functions can have names
                function myFunction() {
                    alert('hello');
                }

        Functions can be anonymous (NOT have names)
                function() {
                    alert('hello');
                }

            Anonymous functions won't do anything on their own. You generally use an anonymous function along with an event handler, for example the following would run the code inside the function whenever the associated button is clicked:

                const myButton = document.querySelector('button');

                myButton.onclick = function() {
                    alert('hello');
                }

            The above example would require there to be a <button> element available on the page to select and click. 

        An anonymous function can be assigned to the value of a variable:

                const myGreeting = function() {
                    alert('hello');
                }
        
            The function can now be invoked using:      myGreeting();
                This effectively gives the function a name.
            
        You can also assign the function to be the value of multiple variables: 

            let anotherGreeting = myGreeting;

        This function can now be invoked using either of:

            myGreeting();
            anotherGreeting();

        But this would be confusing so we don't do it. It is better to just stick to this form:

            function myGreeting() {
                alert('hello');
            }

        You will mainly use anonymous functions to just run a load of code in response to an event firing - like a button being click - using an event handler. Again, this looks something like this: 

            myButton.onclick = function() {
                alert('hello');
                // I can put as much code inside here as I want 
            }

    - Function parameters
        Some functions require parameters to be specified when you are invoking them - these are values that need to be included inside the function parentheses, which it needs to do its job properly. Parameters are sometimes called arguments, properties, or even attributes.

        As an example, the broswer's built-in `Math.random()` function doesn't require any parameters

            let myNumber = Math.random();

        The browser's built-in string `replace()` function however needs two parameters - the substring to find in the main string, and the substring to replace that sting with:

            let myText = 'I am a string';
            let newSting = myText.replace('string', 'sausage');

        It should also be noted that sometiems paraters are optional. If you don't, the function will generally adopt some kind of default behavior. As an example, the array `join()` function's parameter is optional:

            let myArray = ['I', 'love', 'chocolate', 'frogs'];

            let madeAString = myArray.join(' ');
            //returns 'I love chocolate frogs'

            let madeAString = myArray.join();
            // returns 'I, love, chocolate, frogs'

        If no parameter is included to specify a joining/delimiting character, a comma is used by default. 

    - Function scope and conflicts
        When you create a function, the variables and other things defined inside the function are inside their own separate scope, meaning that they are locked away in their own separate compartments, unreachalbe from code outside the functions. 

        The top level outside all your functions is called GLOBAL SCOPE. Values defined in the global scope are accessible from everywhere in the code. 

        JavaScript is set up like this for various reasons - but mainly because of security and organization. Sometimes you don't want variables to be accessible from everywhere in the code - external scripts that you call in from elsewhere could start to mess with your code and cause problems because they happen to be using the same variable names as other parts of the code, causing conflicts. This might be done maliciously, or just by accident. 

        Say you hvae an HTML file that is calling in two external JavaScript files, and both of them have a variable and a function defined that use the same name: 

            <!-- Excerpt from my HTML -->
            <script src="first.js"></script>
            <script src="second.js"></script>
            <script>
                greeting();
            </script>

            // first.js
            let name = 'Chris";
            function greeting() {
                alert('Hello' + name + ': welcome to our company.');
            }
        
            // second.js 
            let name = 'Zaptec';
            function greeting() {
                alert('Our company is called ' + name + '.');
            }

        Both functions you want to call are called `greeting()`, but you can only ever access the `first.js` file's `greeting()` function (the second one is ignored). In addition, attempting to declare the `name` variable a second time with the `let` keyword in the `second.js` file results in an error.

        Keeping parts of your code locked away in functions avoids such proglems, and is considereed the best practice. 
            If code were a zoo, each animal habitat would be a function and the zoo keep is like the global scope - they have the keys to access every enclosure.

        * The same scoping rules do not apply to loop (eg `for() {...}`) and conditional blocks (eg `if() {...}`) - they look very similar, but they are not the same thing. 

        * The 'ReferenceError: "x" is not defined' error is ONE OF THE MOST COMMON you'll encounter. If you get this error and you are sure that you have defined the variable in question, check what scope it is in. 
        
    - Functions inside functions 
        Keep in mind that you can call a function from anywhere, even inside another function. This is often used as a way to keep code tidy - if you have a big comples function, it is easier to understand if you break it down into several sub-functions:

                function.myBigFunction() {
                    let myValue;

                    subFunction1();
                    subFunction2();
                    subFunction3();
                }

                function subFunction1() {
                    console.log(myValue);
                }

                function subFunction2() {
                    console.log(myValue);
                }

                function subFunction3() {
                    console.log(myValue);
                }

        Just make sure that the values being used inside the function are properly in scope. The example above would throw an error `ReferenceError: myValue is not defined`, because although the `myValue` variable is defined in the same scope as the function calls, it is not defined inside the function definitions - the actual code that is run when the functions are called. To make this work, you'd have to pass the value into the function as a parameter, like this: 

                function.myBigFunction() {
                    let myValue;

                    subFunction1(myValue);                  // The `subFunction()` take in `myValue` 
                    subFunction2(myValue);
                    subFunction3(myValue);
                }

                function subFunction1(value) {              // They then assign `myValue` to `value` and 
                    console.log(value);                     // pass `value` to the `console.log()`
                }

                function subFunction2(value) {
                    console.log(value);
                }

                function subFunction3(value) {
                    console.log(value);
                }

